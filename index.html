<!DOCTYPE html>
<html lang="zh-CN">
  <head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>新年快乐 2026</title>

    <script src="https://cdn.tailwindcss.com"></script>
    
    <script crossorigin src="https://unpkg.com/react@18/umd/react.production.min.js"></script>
    <script crossorigin src="https://unpkg.com/react-dom@18/umd/react-dom.production.min.js"></script>

    <script src="https://unpkg.com/@babel/standalone/babel.min.js"></script>
    
    <style>
      body {
        margin: 0;
        overflow: hidden;
        background-color: #000;
        touch-action: none;
      }
    </style>
  </head>
  <body>
    <div id="root"></div>

    <script type="text/babel" data-type="module">
      const Play = ({ size = 24 }) => (
        <svg xmlns="http://www.w3.org/2000/svg" width={size} height={size} viewBox="0 0 24 24" fill="none" stroke="currentColor" strokeWidth="2" strokeLinecap="round" strokeLinejoin="round">
          <polygon points="5 3 19 12 5 21 5 3"></polygon>
        </svg>
      );
      
      const Pause = ({ size = 24 }) => (
        <svg xmlns="http://www.w3.org/2000/svg" width={size} height={size} viewBox="0 0 24 24" fill="none" stroke="currentColor" strokeWidth="2" strokeLinecap="round" strokeLinejoin="round">
          <rect x="6" y="4" width="4" height="16"></rect>
          <rect x="14" y="4" width="4" height="16"></rect>
        </svg>
      );
      
      const SkipForward = ({ size = 24 }) => (
        <svg xmlns="http://www.w3.org/2000/svg" width={size} height={size} viewBox="0 0 24 24" fill="none" stroke="currentColor" strokeWidth="2" strokeLinecap="round" strokeLinejoin="round">
          <polygon points="5 4 15 12 5 20 5 4"></polygon>
          <line x1="19" y1="5" x2="19" y2="19"></line>
        </svg>
      );

      const Fireworks = () => {
        const canvasRef = React.useRef(null);

        React.useEffect(() => {
          const canvas = canvasRef.current;
          if (!canvas) return;

          const ctx = canvas.getContext('2d');
          if (!ctx) return;

          let width = window.innerWidth;
          let height = window.innerHeight;
          canvas.width = width;
          canvas.height = height;

          const fireworks = [];
          const particles = [];

          const random = (min, max) => Math.random() * (max - min) + min;
          
          class Firework {
            constructor(sx, sy, tx, ty, hue) {
              this.x = sx;
              this.y = sy;
              this.sx = sx;
              this.sy = sy;
              this.tx = tx;
              this.ty = ty;
              this.hue = hue;
              this.brightness = random(50, 70);
              this.distanceToTarget = Math.sqrt(Math.pow(tx - sx, 2) + Math.pow(ty - sy, 2));
              this.distanceTraveled = 0;
              this.coordinates = [];
              this.coordinateCount = 3;
              this.angle = Math.atan2(ty - sy, tx - sx);
              this.speed = 2;
              this.acceleration = 1.05;

              while (this.coordinateCount--) {
                this.coordinates.push([this.x, this.y]);
              }
            }

            update(index) {
              this.coordinates.pop();
              this.coordinates.unshift([this.x, this.y]);

              this.speed *= this.acceleration;
              const vx = Math.cos(this.angle) * this.speed;
              const vy = Math.sin(this.angle) * this.speed;

              this.distanceTraveled = Math.sqrt(Math.pow(this.sx - this.x, 2) + Math.pow(this.sy - this.y, 2));

              if (this.distanceTraveled >= this.distanceToTarget) {
                createParticles(this.tx, this.ty, this.hue);
                fireworks.splice(index, 1);
              } else {
                this.x += vx;
                this.y += vy;
              }
            }

            draw() {
              if (!ctx) return;
              ctx.beginPath();
              ctx.moveTo(this.coordinates[this.coordinates.length - 1][0], this.coordinates[this.coordinates.length - 1][1]);
              ctx.lineTo(this.x, this.y);
              ctx.strokeStyle = `hsl(${this.hue}, 100%, ${this.brightness}%)`;
              ctx.stroke();
            }
          }

          class Particle {
            constructor(x, y, hue) {
              this.x = x;
              this.y = y;
              this.coordinates = [];
              this.coordinateCount = 5;
              while (this.coordinateCount--) {
                this.coordinates.push([this.x, this.y]);
              }
              this.hue = random(hue - 20, hue + 20);
              this.angle = random(0, Math.PI * 2);
              this.speed = random(1, 15);
              this.friction = 0.95;
              this.gravity = 1;
              this.brightness = random(50, 80);
              this.alpha = 1;
              this.decay = random(0.005, 0.02);
            }

            update(index) {
              this.coordinates.pop();
              this.coordinates.unshift([this.x, this.y]);
              this.speed *= this.friction;
              this.x += Math.cos(this.angle) * this.speed;
              this.y += Math.sin(this.angle) * this.speed + this.gravity;
              this.alpha -= this.decay;

              if (this.alpha <= this.decay) {
                particles.splice(index, 1);
              }
            }

            draw() {
              if (!ctx) return;
              ctx.beginPath();
              ctx.moveTo(this.coordinates[this.coordinates.length - 1][0], this.coordinates[this.coordinates.length - 1][1]);
              ctx.lineTo(this.x, this.y);
              ctx.strokeStyle = `hsla(${this.hue}, 100%, ${this.brightness}%, ${this.alpha})`;
              ctx.stroke();
            }
          }

          function createParticles(x, y, hue) {
            let particleCount = 150;
            while (particleCount--) {
              particles.push(new Particle(x, y, hue));
            }
          }

          let hue = 120;
          let timerTotal = 30;
          let timerTick = 0;

          const loop = () => {
            if (!ctx) return;
            
            ctx.globalCompositeOperation = 'destination-out';
            ctx.fillStyle = 'rgba(0, 0, 0, 0.2)'; 
            ctx.fillRect(0, 0, width, height);
            ctx.globalCompositeOperation = 'lighter';

            hue += 0.5;

            let i = fireworks.length;
            while (i--) {
              fireworks[i].draw();
              fireworks[i].update(i);
            }

            let j = particles.length;
            while (j--) {
              particles[j].draw();
              particles[j].update(j);
            }

            if (timerTick >= timerTotal) {
              const startX = random(0, width);
              const targetX = random(0, width);
              const targetY = random(0, height / 2);
              
              fireworks.push(new Firework(startX, height, targetX, targetY, hue));
              
              timerTotal = random(15, 40); 
              timerTick = 0;
            } else {
              timerTick++;
            }

            requestAnimationFrame(loop);
          };

          const handleResize = () => {
            width = window.innerWidth;
            height = window.innerHeight;
            canvas.width = width;
            canvas.height = height;
          };

          window.addEventListener('resize', handleResize);
          const animationId = requestAnimationFrame(loop);

          return () => {
            window.removeEventListener('resize', handleResize);
            cancelAnimationFrame(animationId);
          };
        }, []);

        return <canvas ref={canvasRef} className="block w-full h-full opacity-80" />;
      };

      const ParticleText = ({ text }) => {
        const canvasRef = React.useRef(null);

        React.useEffect(() => {
          const canvas = canvasRef.current;
          if (!canvas) return;
          const ctx = canvas.getContext('2d');
          if (!ctx) return;

          let animationFrameId;
          let particles = [];
          const mouse = { x: -9999, y: -9999, radius: 80 };

          let width = window.innerWidth;
          let height = window.innerHeight;

          const particleGap = 4;
          const returnSpeed = 0.1;

          class Particle {
            constructor(x, y, color) {
              this.x = Math.random() * width;
              this.y = Math.random() * height;
              this.targetX = x;
              this.targetY = y;
              this.size = 2;
              this.color = color;
              this.density = Math.random() * 30 + 1;
            }

            draw() {
              if (!ctx) return;
              ctx.fillStyle = this.color;
              ctx.beginPath();
              ctx.arc(this.x, this.y, this.size, 0, Math.PI * 2);
              ctx.closePath();
              ctx.fill();
            }

            update() {
              const dx = mouse.x - this.x;
              const dy = mouse.y - this.y;
              const distance = Math.sqrt(dx * dx + dy * dy);
              
              const forceDirectionX = dx / distance;
              const forceDirectionY = dy / distance;
              const maxDistance = mouse.radius;
              const force = (maxDistance - distance) / maxDistance;
              const directionX = forceDirectionX * force * this.density;
              const directionY = forceDirectionY * force * this.density;

              if (distance < mouse.radius) {
                this.x -= directionX;
                this.y -= directionY;
              } else {
                if (this.x !== this.targetX) {
                  const dxHome = this.x - this.targetX;
                  this.x -= dxHome * returnSpeed;
                }
                if (this.y !== this.targetY) {
                  const dyHome = this.y - this.targetY;
                  this.y -= dyHome * returnSpeed;
                }
              }
              
              this.draw();
            }
          }

          const init = () => {
            particles = [];
            width = window.innerWidth;
            height = window.innerHeight;
            canvas.width = width;
            canvas.height = height;

            const virtualCanvas = document.createElement('canvas');
            virtualCanvas.width = width;
            virtualCanvas.height = height;
            const vCtx = virtualCanvas.getContext('2d');
            if (!vCtx) return;

            const fontSize = Math.min(width * 0.15, 150);
            
            vCtx.fillStyle = 'white';
            vCtx.font = `bold ${fontSize}px "Segoe UI", Tahoma, Geneva, Verdana, sans-serif`;
            vCtx.textAlign = 'center';
            vCtx.textBaseline = 'middle';
            vCtx.fillText(text, width / 2, height / 2);

            const imageData = vCtx.getImageData(0, 0, width, height);
            const data = imageData.data;

            for (let y = 0; y < height; y += particleGap) {
              for (let x = 0; x < width; x += particleGap) {
                const index = (y * width + x) * 4;
                const alpha = data[index + 3];
                
                if (alpha > 128) {
                  const r = data[index];
                  const g = data[index + 1];
                  const b = data[index + 2];
                  
                  const isRed = Math.random() > 0.8;
                  const color = isRed ? '#ff6b6b' : `rgb(${r}, ${g}, ${b})`;
                  
                  particles.push(new Particle(x, y, color));
                }
              }
            }
          };

          const animate = () => {
            if (!ctx) return;
            ctx.clearRect(0, 0, width, height);
            for (let i = 0; i < particles.length; i++) {
              particles[i].update();
            }
            animationFrameId = requestAnimationFrame(animate);
          };

          init();
          animate();

          const handleMouseMove = (e) => {
            mouse.x = e.clientX;
            mouse.y = e.clientY;
          };

          const handleTouchMove = (e) => {
            const touch = e.touches[0];
            mouse.x = touch.clientX;
            mouse.y = touch.clientY;
          }

          const handleResize = () => {
            init();
          };

          window.addEventListener('mousemove', handleMouseMove);
          window.addEventListener('touchmove', handleTouchMove);
          window.addEventListener('resize', handleResize);

          return () => {
            window.removeEventListener('mousemove', handleMouseMove);
            window.removeEventListener('touchmove', handleTouchMove);
            window.removeEventListener('resize', handleResize);
            cancelAnimationFrame(animationFrameId);
          };
        }, [text]);

        return <canvas ref={canvasRef} className="block w-full h-full" />;
      };

      const ImageTrail = ({ items, renderImageBuffer = 20, rotationRange = 25, threshold = 80 }) => {
        const [trail, setTrail] = React.useState([]);
        const trailRef = React.useRef([]);
        const lastPos = React.useRef(null);
        const counter = React.useRef(0);

        React.useEffect(() => {
          const handleMouseMove = (e) => {
            const { clientX, clientY } = e;

            if (!lastPos.current) {
              lastPos.current = { x: clientX, y: clientY };
              return;
            }

            const dx = clientX - lastPos.current.x;
            const dy = clientY - lastPos.current.y;
            const distance = Math.hypot(dx, dy);

            if (distance > threshold) {
              const newId = counter.current++;
              const newItem = {
                id: newId,
                x: clientX,
                y: clientY,
                r: Math.random() * rotationRange * 2 - rotationRange,
                url: items[counter.current % items.length],
              };

              trailRef.current = [...trailRef.current, newItem].slice(-renderImageBuffer);
              setTrail([...trailRef.current]);
              
              lastPos.current = { x: clientX, y: clientY };

              setTimeout(() => {
                trailRef.current = trailRef.current.filter((i) => i.id !== newId);
                setTrail([...trailRef.current]);
              }, 800);
            }
          };

          window.addEventListener("mousemove", handleMouseMove);
          return () => window.removeEventListener("mousemove", handleMouseMove);
        }, [items, threshold, rotationRange, renderImageBuffer]);

        return (
          <div className="pointer-events-none fixed inset-0 z-[5] overflow-hidden">
            {trail.map((item) => (
              <div
                key={item.id}
                className="absolute will-change-transform"
                style={{
                  left: item.x,
                  top: item.y,
                  '--rotation': `${item.r}deg`,
                }}
              >
                <img
                  src={item.url}
                  alt="trail"
                  className="w-32 h-32 sm:w-48 sm:h-48 object-cover rounded-xl shadow-2xl border-2 border-white/30 trail-img-anim"
                />
              </div>
            ))}
            <style>{`
              .trail-img-anim {
                animation: trail-pop 0.8s cubic-bezier(0.16, 1, 0.3, 1) forwards;
              }
              @keyframes trail-pop {
                0% {
                  transform: translate(-50%, -50%) rotate(var(--rotation, 0deg)) scale(0.3);
                  opacity: 0;
                }
                30% {
                  transform: translate(-50%, -50%) rotate(var(--rotation, 0deg)) scale(1.05);
                  opacity: 1;
                }
                60% {
                  transform: translate(-50%, -50%) rotate(var(--rotation, 0deg)) scale(0.95);
                  opacity: 0.8;
                }
                100% {
                  transform: translate(-50%, -50%) rotate(var(--rotation, 0deg)) scale(0.4);
                  opacity: 0;
                }
              }
            `}</style>
          </div>
        );
      };

      // ========== SplashCursor Component ==========
      const SplashCursor = ({
        SIM_RESOLUTION = 128,
        DYE_RESOLUTION = 1440,
        CAPTURE_RESOLUTION = 512,
        DENSITY_DISSIPATION = 3.5,
        VELOCITY_DISSIPATION = 2,
        PRESSURE = 0.1,
        PRESSURE_ITERATIONS = 20,
        CURL = 30,
        SPLAT_RADIUS = 0.25,
        SPLAT_FORCE = 6000,
        SHADING = true,
        COLOR_UPDATE_SPEED = 10,
        BACK_COLOR = { r: 0.5, g: 0, b: 0 },
        TRANSPARENT = true,
      }) => {
        const canvasRef = React.useRef(null);

        React.useEffect(() => {
          const canvas = canvasRef.current;
          if (!canvas) return;

          function pointerPrototype() {
            this.id = -1;
            this.texcoordX = 0;
            this.texcoordY = 0;
            this.prevTexcoordX = 0;
            this.prevTexcoordY = 0;
            this.deltaX = 0;
            this.deltaY = 0;
            this.down = false;
            this.moved = false;
            this.color = [0, 0, 0];
          }

          let config = {
            SIM_RESOLUTION,
            DYE_RESOLUTION,
            CAPTURE_RESOLUTION,
            DENSITY_DISSIPATION,
            VELOCITY_DISSIPATION,
            PRESSURE,
            PRESSURE_ITERATIONS,
            CURL,
            SPLAT_RADIUS,
            SPLAT_FORCE,
            SHADING,
            COLOR_UPDATE_SPEED,
            PAUSED: false,
            BACK_COLOR,
            TRANSPARENT,
          };

          let pointers = [new pointerPrototype()];

          function getSupportedFormat(gl, internalFormat, format, type) {
            if (!supportRenderTextureFormat(gl, internalFormat, format, type)) {
              switch (internalFormat) {
                case gl.R16F:
                  return getSupportedFormat(gl, gl.RG16F, gl.RG, type);
                case gl.RG16F:
                  return getSupportedFormat(gl, gl.RGBA16F, gl.RGBA, type);
                default:
                  return null;
              }
            }
            return { internalFormat, format };
          }

          function supportRenderTextureFormat(gl, internalFormat, format, type) {
            let texture = gl.createTexture();
            gl.bindTexture(gl.TEXTURE_2D, texture);
            gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MIN_FILTER, gl.NEAREST);
            gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MAG_FILTER, gl.NEAREST);
            gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_S, gl.CLAMP_TO_EDGE);
            gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_T, gl.CLAMP_TO_EDGE);
            gl.texImage2D(gl.TEXTURE_2D, 0, internalFormat, 4, 4, 0, format, type, null);

            let fbo = gl.createFramebuffer();
            gl.bindFramebuffer(gl.FRAMEBUFFER, fbo);
            gl.framebufferTexture2D(gl.FRAMEBUFFER, gl.COLOR_ATTACHMENT0, gl.TEXTURE_2D, texture, 0);

            let status = gl.checkFramebufferStatus(gl.FRAMEBUFFER);
            return status === gl.FRAMEBUFFER_COMPLETE;
          }

          const { gl, ext } = getWebGLContext(canvas);

          if (gl && ext) {
            if (!ext.supportLinearFiltering) {
              config.DYE_RESOLUTION = 512;
              config.SHADING = false;
            }
            
            if (!ext.formatRGBA || !ext.formatRG || !ext.formatR) {
              console.warn("SplashCursor: Required WebGL formats not supported");
              return;
            }

            return startAnimation(gl, ext);
          }

          function getWebGLContext(canvas) {
            const params = {
              alpha: true,
              depth: false,
              stencil: false,
              antialias: false,
              preserveDrawingBuffer: false,
            };

            let gl = canvas.getContext('webgl2', params);
            const isWebGL2 = !!gl;
            if (!isWebGL2)
              gl = canvas.getContext('webgl', params) || canvas.getContext('experimental-webgl', params);

            let halfFloat;
            let supportLinearFiltering;
            
            if (!gl) return { gl: null, ext: null };

            if (isWebGL2) {
              gl.getExtension('EXT_color_buffer_float');
              supportLinearFiltering = gl.getExtension('OES_texture_float_linear');
            } else {
              halfFloat = gl.getExtension('OES_texture_half_float');
              supportLinearFiltering = gl.getExtension('OES_texture_half_float_linear');
            }

            gl.clearColor(0.0, 0.0, 0.0, 1.0);

            const halfFloatTexType = isWebGL2 ? gl.HALF_FLOAT : halfFloat && halfFloat.HALF_FLOAT_OES || 0x8d61;
            let formatRGBA;
            let formatRG;
            let formatR;

            if (isWebGL2) {
              formatRGBA = getSupportedFormat(gl, gl.RGBA16F, gl.RGBA, halfFloatTexType);
              formatRG = getSupportedFormat(gl, gl.RG16F, gl.RG, halfFloatTexType);
              formatR = getSupportedFormat(gl, gl.R16F, gl.RED, halfFloatTexType);
            } else {
              formatRGBA = getSupportedFormat(gl, gl.RGBA, gl.RGBA, halfFloatTexType);
              formatRG = getSupportedFormat(gl, gl.RGBA, gl.RGBA, halfFloatTexType);
              formatR = getSupportedFormat(gl, gl.RGBA, gl.RGBA, halfFloatTexType);
            }

            return {
              gl,
              ext: {
                formatRGBA,
                formatRG,
                formatR,
                halfFloatTexType,
                supportLinearFiltering,
              },
            };
          }

          function startAnimation(gl, ext) {
            class Material {
              constructor(vertexShader, fragmentShaderSource) {
                this.vertexShader = vertexShader;
                this.fragmentShaderSource = fragmentShaderSource;
                this.programs = [];
                this.activeProgram = null;
                this.uniforms = [];
              }

              setKeywords(keywords) {
                let hash = 0;
                for (let i = 0; i < keywords.length; i++) hash += hashCode(keywords[i]);

                let program = this.programs[hash];
                if (program == null) {
                  let fragmentShader = compileShader(gl.FRAGMENT_SHADER, this.fragmentShaderSource, keywords);
                  program = createProgram(this.vertexShader, fragmentShader);
                  this.programs[hash] = program;
                }

                if (program === this.activeProgram) return;

                this.uniforms = getUniforms(program);
                this.activeProgram = program;
              }

              bind() {
                gl.useProgram(this.activeProgram);
              }
            }

            class Program {
              constructor(vertexShader, fragmentShader) {
                this.uniforms = {};
                this.program = createProgram(vertexShader, fragmentShader);
                this.uniforms = getUniforms(this.program);
              }

              bind() {
                gl.useProgram(this.program);
              }
            }

            function createProgram(vertexShader, fragmentShader) {
              let program = gl.createProgram();
              gl.attachShader(program, vertexShader);
              gl.attachShader(program, fragmentShader);
              gl.linkProgram(program);

              if (!gl.getProgramParameter(program, gl.LINK_STATUS)) console.trace(gl.getProgramInfoLog(program));

              return program;
            }

            function getUniforms(program) {
              let uniforms = [];
              let uniformCount = gl.getProgramParameter(program, gl.ACTIVE_UNIFORMS);
              for (let i = 0; i < uniformCount; i++) {
                let uniformName = gl.getActiveUniform(program, i).name;
                uniforms[uniformName] = gl.getUniformLocation(program, uniformName);
              }
              return uniforms;
            }

            function compileShader(type, source, keywords) {
              source = addKeywords(source, keywords);

              const shader = gl.createShader(type);
              gl.shaderSource(shader, source);
              gl.compileShader(shader);

              if (!gl.getShaderParameter(shader, gl.COMPILE_STATUS)) console.trace(gl.getShaderInfoLog(shader));

              return shader;
            }

            function addKeywords(source, keywords) {
              if (!keywords) return source;
              let keywordsString = '';
              keywords.forEach((keyword) => {
                keywordsString += '#define ' + keyword + '\n';
              });
              return keywordsString + source;
            }

            const baseVertexShader = compileShader(
              gl.VERTEX_SHADER,
              `
                precision highp float;
                attribute vec2 aPosition;
                varying vec2 vUv;
                varying vec2 vL;
                varying vec2 vR;
                varying vec2 vT;
                varying vec2 vB;
                uniform vec2 texelSize;
                void main () {
                    vUv = aPosition * 0.5 + 0.5;
                    vL = vUv - vec2(texelSize.x, 0.0);
                    vR = vUv + vec2(texelSize.x, 0.0);
                    vT = vUv + vec2(0.0, texelSize.y);
                    vB = vUv - vec2(0.0, texelSize.y);
                    gl_Position = vec4(aPosition, 0.0, 1.0);
                }
              `
            );

            const copyShader = compileShader(
              gl.FRAGMENT_SHADER,
              `
                precision mediump float;
                precision mediump sampler2D;
                varying highp vec2 vUv;
                uniform sampler2D uTexture;
                void main () {
                    gl_FragColor = texture2D(uTexture, vUv);
                }
              `
            );

            const clearShader = compileShader(
              gl.FRAGMENT_SHADER,
              `
                precision mediump float;
                precision mediump sampler2D;
                varying highp vec2 vUv;
                uniform sampler2D uTexture;
                uniform float value;
                void main () {
                    gl_FragColor = value * texture2D(uTexture, vUv);
                }
              `
            );

            const displayShaderSource = `
                precision highp float;
                precision highp sampler2D;
                varying vec2 vUv;
                varying vec2 vL;
                varying vec2 vR;
                varying vec2 vT;
                varying vec2 vB;
                uniform sampler2D uTexture;
                uniform sampler2D uDithering;
                uniform vec2 ditherScale;
                uniform vec2 texelSize;
                vec3 linearToGamma (vec3 color) {
                    color = max(color, vec3(0));
                    return max(1.055 * pow(color, vec3(0.416666667)) - 0.055, vec3(0));
                }
                void main () {
                    vec3 c = texture2D(uTexture, vUv).rgb;
                    #ifdef SHADING
                        vec3 lc = texture2D(uTexture, vL).rgb;
                        vec3 rc = texture2D(uTexture, vR).rgb;
                        vec3 tc = texture2D(uTexture, vT).rgb;
                        vec3 bc = texture2D(uTexture, vB).rgb;
                        float dx = length(rc) - length(lc);
                        float dy = length(tc) - length(bc);
                        vec3 n = normalize(vec3(dx, dy, length(texelSize)));
                        vec3 l = vec3(0.0, 0.0, 1.0);
                        float diffuse = clamp(dot(n, l) + 0.7, 0.7, 1.0);
                        c *= diffuse;
                    #endif
                    float a = max(c.r, max(c.g, c.b));
                    gl_FragColor = vec4(c, a);
                }
            `;

            const splatShader = compileShader(
              gl.FRAGMENT_SHADER,
              `
                precision highp float;
                precision highp sampler2D;
                varying vec2 vUv;
                uniform sampler2D uTarget;
                uniform float aspectRatio;
                uniform vec3 color;
                uniform vec2 point;
                uniform float radius;
                void main () {
                    vec2 p = vUv - point.xy;
                    p.x *= aspectRatio;
                    vec3 splat = exp(-dot(p, p) / radius) * color;
                    vec3 base = texture2D(uTarget, vUv).xyz;
                    gl_FragColor = vec4(base + splat, 1.0);
                }
              `
            );

            const advectionShader = compileShader(
              gl.FRAGMENT_SHADER,
              `
                precision highp float;
                precision highp sampler2D;
                varying vec2 vUv;
                uniform sampler2D uVelocity;
                uniform sampler2D uSource;
                uniform vec2 texelSize;
                uniform vec2 dyeTexelSize;
                uniform float dt;
                uniform float dissipation;
                vec4 bilerp (sampler2D sam, vec2 uv, vec2 tsize) {
                    vec2 st = uv / tsize - 0.5;
                    vec2 iuv = floor(st);
                    vec2 fuv = fract(st);
                    vec4 a = texture2D(sam, (iuv + vec2(0.5, 0.5)) * tsize);
                    vec4 b = texture2D(sam, (iuv + vec2(1.5, 0.5)) * tsize);
                    vec4 c = texture2D(sam, (iuv + vec2(0.5, 1.5)) * tsize);
                    vec4 d = texture2D(sam, (iuv + vec2(1.5, 1.5)) * tsize);
                    return mix(mix(a, b, fuv.x), mix(c, d, fuv.x), fuv.y);
                }
                void main () {
                    #ifdef MANUAL_FILTERING
                        vec2 coord = vUv - dt * bilerp(uVelocity, vUv, texelSize).xy * texelSize;
                        vec4 result = bilerp(uSource, coord, dyeTexelSize);
                    #else
                        vec2 coord = vUv - dt * texture2D(uVelocity, vUv).xy * texelSize;
                        vec4 result = texture2D(uSource, coord);
                    #endif
                    float decay = 1.0 + dissipation * dt;
                    gl_FragColor = result / decay;
                }
              `,
              ext.supportLinearFiltering ? null : ['MANUAL_FILTERING']
            );

            const divergenceShader = compileShader(
              gl.FRAGMENT_SHADER,
              `
                precision mediump float;
                precision mediump sampler2D;
                varying highp vec2 vUv;
                varying highp vec2 vL;
                varying highp vec2 vR;
                varying highp vec2 vT;
                varying highp vec2 vB;
                uniform sampler2D uVelocity;
                void main () {
                    float L = texture2D(uVelocity, vL).x;
                    float R = texture2D(uVelocity, vR).x;
                    float T = texture2D(uVelocity, vT).y;
                    float B = texture2D(uVelocity, vB).y;
                    vec2 C = texture2D(uVelocity, vUv).xy;
                    if (vL.x < 0.0) { L = -C.x; }
                    if (vR.x > 1.0) { R = -C.x; }
                    if (vT.y > 1.0) { T = -C.y; }
                    if (vB.y < 0.0) { B = -C.y; }
                    float div = 0.5 * (R - L + T - B);
                    gl_FragColor = vec4(div, 0.0, 0.0, 1.0);
                }
              `
            );

            const curlShader = compileShader(
              gl.FRAGMENT_SHADER,
              `
                precision mediump float;
                precision mediump sampler2D;
                varying highp vec2 vUv;
                varying highp vec2 vL;
                varying highp vec2 vR;
                varying highp vec2 vT;
                varying highp vec2 vB;
                uniform sampler2D uVelocity;
                void main () {
                    float L = texture2D(uVelocity, vL).y;
                    float R = texture2D(uVelocity, vR).y;
                    float T = texture2D(uVelocity, vT).x;
                    float B = texture2D(uVelocity, vB).x;
                    float vorticity = R - L - T + B;
                    gl_FragColor = vec4(0.5 * vorticity, 0.0, 0.0, 1.0);
                }
              `
            );

            const vorticityShader = compileShader(
              gl.FRAGMENT_SHADER,
              `
                precision highp float;
                precision highp sampler2D;
                varying vec2 vUv;
                varying vec2 vL;
                varying vec2 vR;
                varying vec2 vT;
                varying vec2 vB;
                uniform sampler2D uVelocity;
                uniform sampler2D uCurl;
                uniform float curl;
                uniform float dt;
                void main () {
                    float L = texture2D(uCurl, vL).x;
                    float R = texture2D(uCurl, vR).x;
                    float T = texture2D(uCurl, vT).x;
                    float B = texture2D(uCurl, vB).x;
                    float C = texture2D(uCurl, vUv).x;
                    vec2 force = 0.5 * vec2(abs(T) - abs(B), abs(R) - abs(L));
                    force /= length(force) + 0.0001;
                    force *= curl * C;
                    force.y *= -1.0;
                    vec2 velocity = texture2D(uVelocity, vUv).xy;
                    velocity += force * dt;
                    velocity = min(max(velocity, -1000.0), 1000.0);
                    gl_FragColor = vec4(velocity, 0.0, 1.0);
                }
              `
            );

            const pressureShader = compileShader(
              gl.FRAGMENT_SHADER,
              `
                precision mediump float;
                precision mediump sampler2D;
                varying highp vec2 vUv;
                varying highp vec2 vL;
                varying highp vec2 vR;
                varying highp vec2 vT;
                varying highp vec2 vB;
                uniform sampler2D uPressure;
                uniform sampler2D uDivergence;
                void main () {
                    float L = texture2D(uPressure, vL).x;
                    float R = texture2D(uPressure, vR).x;
                    float T = texture2D(uPressure, vT).x;
                    float B = texture2D(uPressure, vB).x;
                    float C = texture2D(uPressure, vUv).x;
                    float divergence = texture2D(uDivergence, vUv).x;
                    float pressure = (L + R + B + T - divergence) * 0.25;
                    gl_FragColor = vec4(pressure, 0.0, 0.0, 1.0);
                }
              `
            );

            const gradientSubtractShader = compileShader(
              gl.FRAGMENT_SHADER,
              `
                precision mediump float;
                precision mediump sampler2D;
                varying highp vec2 vUv;
                varying highp vec2 vL;
                varying highp vec2 vR;
                varying highp vec2 vT;
                varying highp vec2 vB;
                uniform sampler2D uPressure;
                uniform sampler2D uVelocity;
                void main () {
                    float L = texture2D(uPressure, vL).x;
                    float R = texture2D(uPressure, vR).x;
                    float T = texture2D(uPressure, vT).x;
                    float B = texture2D(uPressure, vB).x;
                    vec2 velocity = texture2D(uVelocity, vUv).xy;
                    velocity.xy -= vec2(R - L, T - B);
                    gl_FragColor = vec4(velocity, 0.0, 1.0);
                }
              `
            );

            const blit = (() => {
              gl.bindBuffer(gl.ARRAY_BUFFER, gl.createBuffer());
              gl.bufferData(gl.ARRAY_BUFFER, new Float32Array([-1, -1, -1, 1, 1, 1, 1, -1]), gl.STATIC_DRAW);
              gl.bindBuffer(gl.ELEMENT_ARRAY_BUFFER, gl.createBuffer());
              gl.bufferData(gl.ELEMENT_ARRAY_BUFFER, new Uint16Array([0, 1, 2, 0, 2, 3]), gl.STATIC_DRAW);
              gl.vertexAttribPointer(0, 2, gl.FLOAT, false, 0, 0);
              gl.enableVertexAttribArray(0);

              return (target, clear = false) => {
                if (target == null) {
                  gl.viewport(0, 0, gl.drawingBufferWidth, gl.drawingBufferHeight);
                  gl.bindFramebuffer(gl.FRAMEBUFFER, null);
                } else {
                  gl.viewport(0, 0, target.width, target.height);
                  gl.bindFramebuffer(gl.FRAMEBUFFER, target.fbo);
                }
                if (clear) {
                  gl.clearColor(0.0, 0.0, 0.0, 1.0);
                  gl.clear(gl.COLOR_BUFFER_BIT);
                }
                gl.drawElements(gl.TRIANGLES, 6, gl.UNSIGNED_SHORT, 0);
              };
            })();

            let dye, velocity, divergence, curl, pressure;

            const copyProgram = new Program(baseVertexShader, copyShader);
            const clearProgram = new Program(baseVertexShader, clearShader);
            const splatProgram = new Program(baseVertexShader, splatShader);
            const advectionProgram = new Program(baseVertexShader, advectionShader);
            const divergenceProgram = new Program(baseVertexShader, divergenceShader);
            const curlProgram = new Program(baseVertexShader, curlShader);
            const vorticityProgram = new Program(baseVertexShader, vorticityShader);
            const pressureProgram = new Program(baseVertexShader, pressureShader);
            const gradienSubtractProgram = new Program(baseVertexShader, gradientSubtractShader);

            const displayMaterial = new Material(baseVertexShader, displayShaderSource);

            function initFramebuffers() {
              let simRes = getResolution(config.SIM_RESOLUTION);
              let dyeRes = getResolution(config.DYE_RESOLUTION);

              const texType = ext.halfFloatTexType;
              const rgba = ext.formatRGBA;
              const rg = ext.formatRG;
              const r = ext.formatR;
              const filtering = ext.supportLinearFiltering ? gl.LINEAR : gl.NEAREST;

              gl.disable(gl.BLEND);

              if (!dye)
                dye = createDoubleFBO(dyeRes.width, dyeRes.height, rgba.internalFormat, rgba.format, texType, filtering);
              else
                dye = resizeDoubleFBO(dye, dyeRes.width, dyeRes.height, rgba.internalFormat, rgba.format, texType, filtering);

              if (!velocity)
                velocity = createDoubleFBO(simRes.width, simRes.height, rg.internalFormat, rg.format, texType, filtering);
              else
                velocity = resizeDoubleFBO(velocity, simRes.width, simRes.height, rg.internalFormat, rg.format, texType, filtering);

              divergence = createFBO(simRes.width, simRes.height, r.internalFormat, r.format, texType, gl.NEAREST);
              curl = createFBO(simRes.width, simRes.height, r.internalFormat, r.format, texType, gl.NEAREST);
              pressure = createDoubleFBO(simRes.width, simRes.height, r.internalFormat, r.format, texType, gl.NEAREST);
            }

            function createFBO(w, h, internalFormat, format, type, param) {
              gl.activeTexture(gl.TEXTURE0);
              let texture = gl.createTexture();
              gl.bindTexture(gl.TEXTURE_2D, texture);
              gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MIN_FILTER, param);
              gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MAG_FILTER, param);
              gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_S, gl.CLAMP_TO_EDGE);
              gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_T, gl.CLAMP_TO_EDGE);
              gl.texImage2D(gl.TEXTURE_2D, 0, internalFormat, w, h, 0, format, type, null);

              let fbo = gl.createFramebuffer();
              gl.bindFramebuffer(gl.FRAMEBUFFER, fbo);
              gl.framebufferTexture2D(gl.FRAMEBUFFER, gl.COLOR_ATTACHMENT0, gl.TEXTURE_2D, texture, 0);
              gl.viewport(0, 0, w, h);
              gl.clear(gl.COLOR_BUFFER_BIT);

              let texelSizeX = 1.0 / w;
              let texelSizeY = 1.0 / h;

              return {
                texture,
                fbo,
                width: w,
                height: h,
                texelSizeX,
                texelSizeY,
                attach(id) {
                  gl.activeTexture(gl.TEXTURE0 + id);
                  gl.bindTexture(gl.TEXTURE_2D, texture);
                  return id;
                },
              };
            }

            function createDoubleFBO(w, h, internalFormat, format, type, param) {
              let fbo1 = createFBO(w, h, internalFormat, format, type, param);
              let fbo2 = createFBO(w, h, internalFormat, format, type, param);

              return {
                width: w,
                height: h,
                texelSizeX: fbo1.texelSizeX,
                texelSizeY: fbo1.texelSizeY,
                get read() { return fbo1; },
                set read(value) { fbo1 = value; },
                get write() { return fbo2; },
                set write(value) { fbo2 = value; },
                swap() {
                  let temp = fbo1;
                  fbo1 = fbo2;
                  fbo2 = temp;
                },
              };
            }

            function resizeFBO(target, w, h, internalFormat, format, type, param) {
              let newFBO = createFBO(w, h, internalFormat, format, type, param);
              copyProgram.bind();
              gl.uniform1i(copyProgram.uniforms.uTexture, target.attach(0));
              blit(newFBO);
              return newFBO;
            }

            function resizeDoubleFBO(target, w, h, internalFormat, format, type, param) {
              if (target.width === w && target.height === h) return target;
              target.read = resizeFBO(target.read, w, h, internalFormat, format, type, param);
              target.write = createFBO(w, h, internalFormat, format, type, param);
              target.width = w;
              target.height = h;
              target.texelSizeX = 1.0 / w;
              target.texelSizeY = 1.0 / h;
              return target;
            }

            function updateKeywords() {
              let displayKeywords = [];
              if (config.SHADING) displayKeywords.push('SHADING');
              displayMaterial.setKeywords(displayKeywords);
            }

            updateKeywords();
            initFramebuffers();

            let lastUpdateTime = Date.now();
            let colorUpdateTimer = 0.0;
            let animationId;

            function updateFrame() {
              const dt = calcDeltaTime();
              if (resizeCanvas()) initFramebuffers();
              updateColors(dt);
              applyInputs();
              step(dt);
              render(null);
              animationId = requestAnimationFrame(updateFrame);
            }

            function calcDeltaTime() {
              let now = Date.now();
              let dt = (now - lastUpdateTime) / 1000;
              dt = Math.min(dt, 0.016666);
              lastUpdateTime = now;
              return dt;
            }

            function resizeCanvas() {
              let width = scaleByPixelRatio(canvas.clientWidth);
              let height = scaleByPixelRatio(canvas.clientHeight);
              if (canvas.width !== width || canvas.height !== height) {
                canvas.width = width;
                canvas.height = height;
                return true;
              }
              return false;
            }

            function updateColors(dt) {
              colorUpdateTimer += dt * config.COLOR_UPDATE_SPEED;
              if (colorUpdateTimer >= 1) {
                colorUpdateTimer = wrap(colorUpdateTimer, 0, 1);
                pointers.forEach((p) => {
                  p.color = generateColor();
                });
              }
            }

            function applyInputs() {
              pointers.forEach((p) => {
                if (p.moved) {
                  p.moved = false;
                  splatPointer(p);
                }
              });
            }

            function step(dt) {
              gl.disable(gl.BLEND);

              curlProgram.bind();
              gl.uniform2f(curlProgram.uniforms.texelSize, velocity.texelSizeX, velocity.texelSizeY);
              gl.uniform1i(curlProgram.uniforms.uVelocity, velocity.read.attach(0));
              blit(curl);

              vorticityProgram.bind();
              gl.uniform2f(vorticityProgram.uniforms.texelSize, velocity.texelSizeX, velocity.texelSizeY);
              gl.uniform1i(vorticityProgram.uniforms.uVelocity, velocity.read.attach(0));
              gl.uniform1i(vorticityProgram.uniforms.uCurl, curl.attach(1));
              gl.uniform1f(vorticityProgram.uniforms.curl, config.CURL);
              gl.uniform1f(vorticityProgram.uniforms.dt, dt);
              blit(velocity.write);
              velocity.swap();

              divergenceProgram.bind();
              gl.uniform2f(divergenceProgram.uniforms.texelSize, velocity.texelSizeX, velocity.texelSizeY);
              gl.uniform1i(divergenceProgram.uniforms.uVelocity, velocity.read.attach(0));
              blit(divergence);

              clearProgram.bind();
              gl.uniform1i(clearProgram.uniforms.uTexture, pressure.read.attach(0));
              gl.uniform1f(clearProgram.uniforms.value, config.PRESSURE);
              blit(pressure.write);
              pressure.swap();

              pressureProgram.bind();
              gl.uniform2f(pressureProgram.uniforms.texelSize, velocity.texelSizeX, velocity.texelSizeY);
              gl.uniform1i(pressureProgram.uniforms.uDivergence, divergence.attach(0));
              for (let i = 0; i < config.PRESSURE_ITERATIONS; i++) {
                gl.uniform1i(pressureProgram.uniforms.uPressure, pressure.read.attach(1));
                blit(pressure.write);
                pressure.swap();
              }

              gradienSubtractProgram.bind();
              gl.uniform2f(gradienSubtractProgram.uniforms.texelSize, velocity.texelSizeX, velocity.texelSizeY);
              gl.uniform1i(gradienSubtractProgram.uniforms.uPressure, pressure.read.attach(0));
              gl.uniform1i(gradienSubtractProgram.uniforms.uVelocity, velocity.read.attach(1));
              blit(velocity.write);
              velocity.swap();

              advectionProgram.bind();
              gl.uniform2f(advectionProgram.uniforms.texelSize, velocity.texelSizeX, velocity.texelSizeY);
              if (!ext.supportLinearFiltering)
                gl.uniform2f(advectionProgram.uniforms.dyeTexelSize, velocity.texelSizeX, velocity.texelSizeY);
              let velocityId = velocity.read.attach(0);
              gl.uniform1i(advectionProgram.uniforms.uVelocity, velocityId);
              gl.uniform1i(advectionProgram.uniforms.uSource, velocityId);
              gl.uniform1f(advectionProgram.uniforms.dt, dt);
              gl.uniform1f(advectionProgram.uniforms.dissipation, config.VELOCITY_DISSIPATION);
              blit(velocity.write);
              velocity.swap();

              if (!ext.supportLinearFiltering)
                gl.uniform2f(advectionProgram.uniforms.dyeTexelSize, dye.texelSizeX, dye.texelSizeY);
              gl.uniform1i(advectionProgram.uniforms.uVelocity, velocity.read.attach(0));
              gl.uniform1i(advectionProgram.uniforms.uSource, dye.read.attach(1));
              gl.uniform1f(advectionProgram.uniforms.dissipation, config.DENSITY_DISSIPATION);
              blit(dye.write);
              dye.swap();
            }

            function render(target) {
              gl.blendFunc(gl.ONE, gl.ONE_MINUS_SRC_ALPHA);
              gl.enable(gl.BLEND);
              drawDisplay(target);
            }

            function drawDisplay(target) {
              let width = target == null ? gl.drawingBufferWidth : target.width;
              let height = target == null ? gl.drawingBufferHeight : target.height;

              displayMaterial.bind();
              if (config.SHADING)
                gl.uniform2f(displayMaterial.uniforms.texelSize, 1.0 / width, 1.0 / height);
              gl.uniform1i(displayMaterial.uniforms.uTexture, dye.read.attach(0));
              blit(target);
            }

            function splatPointer(pointer) {
              let dx = pointer.deltaX * config.SPLAT_FORCE;
              let dy = pointer.deltaY * config.SPLAT_FORCE;
              splat(pointer.texcoordX, pointer.texcoordY, dx, dy, pointer.color);
            }

            function clickSplat(pointer) {
              const color = generateColor();
              color.r *= 10.0;
              color.g *= 10.0;
              color.b *= 10.0;
              let dx = 10 * (Math.random() - 0.5);
              let dy = 30 * (Math.random() - 0.5);
              splat(pointer.texcoordX, pointer.texcoordY, dx, dy, color);
            }

            function splat(x, y, dx, dy, color) {
              splatProgram.bind();
              gl.uniform1i(splatProgram.uniforms.uTarget, velocity.read.attach(0));
              gl.uniform1f(splatProgram.uniforms.aspectRatio, canvas.width / canvas.height);
              gl.uniform2f(splatProgram.uniforms.point, x, y);
              gl.uniform3f(splatProgram.uniforms.color, dx, dy, 0.0);
              gl.uniform1f(splatProgram.uniforms.radius, correctRadius(config.SPLAT_RADIUS / 100.0));
              blit(velocity.write);
              velocity.swap();

              gl.uniform1i(splatProgram.uniforms.uTarget, dye.read.attach(0));
              gl.uniform3f(splatProgram.uniforms.color, color.r, color.g, color.b);
              blit(dye.write);
              dye.swap();
            }

            function correctRadius(radius) {
              let aspectRatio = canvas.width / canvas.height;
              if (aspectRatio > 1) radius *= aspectRatio;
              return radius;
            }

            function updatePointerDownData(pointer, id, posX, posY) {
              pointer.id = id;
              pointer.down = true;
              pointer.moved = false;
              pointer.texcoordX = posX / canvas.width;
              pointer.texcoordY = 1.0 - posY / canvas.height;
              pointer.prevTexcoordX = pointer.texcoordX;
              pointer.prevTexcoordY = pointer.texcoordY;
              pointer.deltaX = 0;
              pointer.deltaY = 0;
              pointer.color = generateColor();
            }

            function updatePointerMoveData(pointer, posX, posY, color) {
              pointer.prevTexcoordX = pointer.texcoordX;
              pointer.prevTexcoordY = pointer.texcoordY;
              pointer.texcoordX = posX / canvas.width;
              pointer.texcoordY = 1.0 - posY / canvas.height;
              pointer.deltaX = correctDeltaX(pointer.texcoordX - pointer.prevTexcoordX);
              pointer.deltaY = correctDeltaY(pointer.texcoordY - pointer.prevTexcoordY);
              pointer.moved = Math.abs(pointer.deltaX) > 0 || Math.abs(pointer.deltaY) > 0;
              pointer.color = color;
            }

            function updatePointerUpData(pointer) {
              pointer.down = false;
            }

            function correctDeltaX(delta) {
              let aspectRatio = canvas.width / canvas.height;
              if (aspectRatio < 1) delta *= aspectRatio;
              return delta;
            }

            function correctDeltaY(delta) {
              let aspectRatio = canvas.width / canvas.height;
              if (aspectRatio > 1) delta /= aspectRatio;
              return delta;
            }

            function generateColor() {
              let c = HSVtoRGB(Math.random(), 1.0, 1.0);
              c.r *= 0.15;
              c.g *= 0.15;
              c.b *= 0.15;
              return c;
            }

            function HSVtoRGB(h, s, v) {
              let r, g, b, i, f, p, q, t;
              i = Math.floor(h * 6);
              f = h * 6 - i;
              p = v * (1 - s);
              q = v * (1 - f * s);
              t = v * (1 - (1 - f) * s);

              switch (i % 6) {
                case 0: r = v; g = t; b = p; break;
                case 1: r = q; g = v; b = p; break;
                case 2: r = p; g = v; b = t; break;
                case 3: r = p; g = q; b = v; break;
                case 4: r = t; g = p; b = v; break;
                case 5: r = v; g = p; b = q; break;
              }

              return { r, g, b };
            }

            function wrap(value, min, max) {
              const range = max - min;
              if (range === 0) return min;
              return ((value - min) % range) + min;
            }

            function getResolution(resolution) {
              let aspectRatio = gl.drawingBufferWidth / gl.drawingBufferHeight;
              if (aspectRatio < 1) aspectRatio = 1.0 / aspectRatio;

              const min = Math.round(resolution);
              const max = Math.round(resolution * aspectRatio);

              if (gl.drawingBufferWidth > gl.drawingBufferHeight) return { width: max, height: min };
              else return { width: min, height: max };
            }

            function scaleByPixelRatio(input) {
              const pixelRatio = window.devicePixelRatio || 1;
              return Math.floor(input * pixelRatio);
            }

            function hashCode(s) {
              if (s.length === 0) return 0;
              let hash = 0;
              for (let i = 0; i < s.length; i++) {
                hash = (hash << 5) - hash + s.charCodeAt(i);
                hash |= 0;
              }
              return hash;
            }

            const onMouseDown = (e) => {
              let pointer = pointers[0];
              let posX = scaleByPixelRatio(e.clientX);
              let posY = scaleByPixelRatio(e.clientY);
              updatePointerDownData(pointer, -1, posX, posY);
              clickSplat(pointer);
            };

            const onMouseMove = (e) => {
              let pointer = pointers[0];
              let posX = scaleByPixelRatio(e.clientX);
              let posY = scaleByPixelRatio(e.clientY);
              let color = pointer.color;
              updatePointerMoveData(pointer, posX, posY, color);
            };

            const onTouchStart = (e) => {
              const touches = e.targetTouches;
              let pointer = pointers[0];
              for (let i = 0; i < touches.length; i++) {
                let posX = scaleByPixelRatio(touches[i].clientX);
                let posY = scaleByPixelRatio(touches[i].clientY);
                updatePointerDownData(pointer, touches[i].identifier, posX, posY);
              }
            };

            const onTouchMove = (e) => {
              const touches = e.targetTouches;
              let pointer = pointers[0];
              for (let i = 0; i < touches.length; i++) {
                let posX = scaleByPixelRatio(touches[i].clientX);
                let posY = scaleByPixelRatio(touches[i].clientY);
                updatePointerMoveData(pointer, posX, posY, pointer.color);
              }
            };

            const onTouchEnd = (e) => {
              const touches = e.changedTouches;
              let pointer = pointers[0];
              for (let i = 0; i < touches.length; i++) {
                updatePointerUpData(pointer);
              }
            };

            const handleFirstMouseMove = (e) => {
              let pointer = pointers[0];
              let posX = scaleByPixelRatio(e.clientX);
              let posY = scaleByPixelRatio(e.clientY);
              let color = generateColor();
              updateFrame();
              updatePointerMoveData(pointer, posX, posY, color);
              window.removeEventListener('mousemove', handleFirstMouseMove);
            };

            const handleFirstTouchStart = (e) => {
              const touches = e.targetTouches;
              let pointer = pointers[0];
              for (let i = 0; i < touches.length; i++) {
                let posX = scaleByPixelRatio(touches[i].clientX);
                let posY = scaleByPixelRatio(touches[i].clientY);
                updateFrame();
                updatePointerDownData(pointer, touches[i].identifier, posX, posY);
              }
              window.removeEventListener('touchstart', handleFirstTouchStart);
            };

            window.addEventListener('mousedown', onMouseDown);
            window.addEventListener('mousemove', onMouseMove);
            window.addEventListener('touchstart', onTouchStart);
            window.addEventListener('touchmove', onTouchMove);
            window.addEventListener('touchend', onTouchEnd);
            
            window.addEventListener('mousemove', handleFirstMouseMove);
            window.addEventListener('touchstart', handleFirstTouchStart);

            return () => {
              window.removeEventListener('mousedown', onMouseDown);
              window.removeEventListener('mousemove', onMouseMove);
              window.removeEventListener('touchstart', onTouchStart);
              window.removeEventListener('touchmove', onTouchMove);
              window.removeEventListener('touchend', onTouchEnd);
              
              window.removeEventListener('mousemove', handleFirstMouseMove);
              window.removeEventListener('touchstart', handleFirstTouchStart);
              
              cancelAnimationFrame(animationId);
            };
          }
        }, [
          SIM_RESOLUTION,
          DYE_RESOLUTION,
          CAPTURE_RESOLUTION,
          DENSITY_DISSIPATION,
          VELOCITY_DISSIPATION,
          PRESSURE,
          PRESSURE_ITERATIONS,
          CURL,
          SPLAT_RADIUS,
          SPLAT_FORCE,
          SHADING,
          COLOR_UPDATE_SPEED,
          BACK_COLOR,
          TRANSPARENT,
        ]);

        return (
          <div
            style={{
              position: 'fixed',
              top: 0,
              left: 0,
              zIndex: 50,
              pointerEvents: 'none',
              width: '100%',
              height: '100%',
            }}
          >
            <canvas
              ref={canvasRef}
              id="fluid"
              style={{
                width: '100vw',
                height: '100vh',
                display: 'block',
              }}
            />
          </div>
        );
      };

      const MESSAGES = [
        "再见 2025",
        "To ",
        "祝 ",
        "万事如意",
        "身体健康",
        "新年快乐 ",
        "一月一号 宜悦宜好！",
        "❤"
      ]

      const MUSIC_URL = "https://s1.aigei.com/src/aud/mp3/33/33cd1a1a37d1415587a20d2ae22e9b80.mp3?e=1766048460&token=P7S2Xpzfz11vAkASLTkfHN7Fw-oOZBecqeJaxypL:vau2DeTIP3xrFs-7vsR45zahWTQ=";

      const App = () => {
        const [currentIndex, setCurrentIndex] = React.useState(0);
        const [isPlaying, setIsPlaying] = React.useState(true);
        const audioRef = React.useRef(null);
        React.useEffect(() => {
          if (audioRef.current) {
            if (isPlaying) {
              audioRef.current.play().catch((e) => {
                console.log("Autoplay blocked, waiting for interaction", e);
                setIsPlaying(false);
              });
            } else {
              audioRef.current.pause();
            }
          }
        }, [isPlaying]);

        React.useEffect(() => {
          if (audioRef.current) {
            audioRef.current.volume = 0.5;
          }
        }, []);

        React.useEffect(() => {
          let timer;
          if (isPlaying) {
            timer = setTimeout(() => {
              setCurrentIndex((prev) => (prev + 1) % MESSAGES.length);
            }, 4000);
          }
          return () => clearTimeout(timer);
        }, [currentIndex, isPlaying]);

        const togglePlay = (e) => {
          e.stopPropagation();
          setIsPlaying(!isPlaying);
        };

        const nextMessage = (e) => {
          e.stopPropagation();
          setCurrentIndex((prev) => (prev + 1) % MESSAGES.length);
        };

        const handleGlobalClick = () => {
          if (!isPlaying) {
            setIsPlaying(true);
          }
        };

        return (
          <div 
            className="relative w-full h-screen bg-black overflow-hidden select-none"
            onClick={handleGlobalClick}
          >
            <audio ref={audioRef} src={MUSIC_URL} loop playsInline />

            <SplashCursor 
              SIM_RESOLUTION={128}
              DYE_RESOLUTION={1024}
              SPLAT_FORCE={6000}
            />


            <div className="absolute inset-0 z-0">
              <Fireworks />
            </div>

            <div className="absolute inset-0 z-10">
              <ParticleText text={MESSAGES[currentIndex]} />
            </div>

            <div className="absolute bottom-10 left-0 right-0 z-20 flex justify-center items-center gap-6 opacity-0 hover:opacity-100 transition-opacity duration-300">
              <button
                onClick={togglePlay}
                className="p-3 rounded-full bg-white/10 hover:bg-white/20 backdrop-blur-sm text-white transition-all transform hover:scale-110 pointer-events-auto flex items-center gap-2"
                title={isPlaying ? "Pause" : "Play Music & Animation"}
              >
                {isPlaying ? <Pause size={24} /> : <Play size={24} />}
              </button>
              <button
                onClick={nextMessage}
                className="p-3 rounded-full bg-white/10 hover:bg-white/20 backdrop-blur-sm text-white transition-all transform hover:scale-110 pointer-events-auto"
                title="Next Message"
              >
                <SkipForward size={24} />
              </button>
            </div>
            
            <div className="absolute bottom-4 left-0 right-0 text-center text-white/30 text-xs z-20 pointer-events-none">
              小文祝你新年快乐
            </div>
          </div>
        );
      };

      const root = ReactDOM.createRoot(document.getElementById('root'));
      root.render(<App />);
    </script>
  </body>
</html>